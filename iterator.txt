Roast+でのイテレータは、STL等のものとは若干仕様が異なります。

STLのイテレータでは、「ポインタと同様に動作する」と言うコンセプトの元作られており、これを実現するため、begin()とend()の両方を取得しend()になるまでループする、と言う形になっています。

しかしこのために、例えばSTLのalgorithm等では、begin()とend()の両方のイテレータを渡さねばならず、場合によっては2コンテナ分のイテレータ（つまり合計4つのイテレータ）を渡さなければいけないアルゴリズム関数もあります。また、自前で作成した関数等の場合においても同様で、正直面倒です。（多くの人は、イテレータを渡すのではなくコンテナそのものへの参照やポインタを渡していて、実質イテレータと言うものが形骸化しているのではないかとも思います）

この問題を回避するために、Roast+では「ポインタと同様に動作する」と言う考え方を捨て、単純にクラスとして振る舞い、また終端判断も「is_valid()」と言うメソッド一つで行えるようにしました。サンプルコードとしては以下のようなものです。

{{{ code cpp
roast::primitive_vector<int> ary;
ary.push_back(1);
ary.push_back(2);
ary.push_back(3);

for(roast::primitive_vector<int>::iterator it=ary.get_iterator(); it.is_valid(); it.next())
{
	std::cout << it.get_value() << std::endl;
}
}}}

